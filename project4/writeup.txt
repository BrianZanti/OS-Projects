I implemented the barrier as a struct that contains a condition variable, a counter of how many threads are currently running, and a mutex. Whenever a thread reaches the end of its sorting, it locks the mutex so that it may have exclusive access to the barrier. The thread then decrements the counter and checks to see if is zero. If the counter is not at zero, this indicates that other threads are still working. The thread will then call wait on the condition variable and unlock the mutex, waiting for a broadcast from the final thread to finish. If the counter is at zero, this indicates that all threads are finished and it then calls the broadcast function to release all other threads waiting on the condition variable. Once a thread receives this broadcast it will try to obtain a lock on the mutex. Once this happens, it again checks to see if the count is zero (which it must be since broadcast can only be called by the last thread to finish when the count is zero), at which point it is released from the while loop and unlocks the mutex as it no longer needs access to the barrier. Each thread except for the last one to finish is thus sequentially released from waiting on the condition variable, given a mutex lock, and allowed to exit.

I was not truly able to test the barrier until I used inputs of 512 and greater since lower numbers may make it seem like the barrier is synchronizing the threads when they are not. Using these larger inputs, I ran the code using the gdb debugger, placing breakpoints after each iteration of sorting. The debugger indicates to you when threads are created and terminated. Running my code, the correct number of threads are created for each round of sorted, followed by the same number of threads exiting. This indicates that each thread must be created and finish its sorting before any thread can terminate, thus following the assignment specifications. 

My main thread does not participate in comparison. The main thread only launches all the worker threads and waits for them to finish using the same process as the worker threads (waiting on a condition variable broadcast and for the counter to hit zero). Once a worker thread is launched is its responsibility to manage the sections of the array it is responsible for. This is indicated by passing the worker thread a start index and a length, thus sectioning off a part of the array for the thread to work with. The main thread need not take any part in the sorting.

The results were stored in a vector, which is essentially an array. The reason I chose to use a vector was because initially the length of the data is unknown, and vectors are much easier to work with when the final size is unknown. When the threads are sorting they create a temporary array with length equal to the length passed as a parameter. The thread fills in the spots in the temporary array sequentially by selecting the lowest remaining value of the two halves of the section of the original array it is responsible for as per the merge sort algorithm. Once the temporary array is filled, the thread copies the values from the temporary array into the correct section of the original array. So all sorting results are stored in the original array and all sorting happens within smaller temporary arrays.
