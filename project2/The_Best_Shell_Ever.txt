The Best Shell Ever

By Nathan Farmer and Brian Zanti

Our implementation for the solution to this project begins with parsing through the commands that are inputted into the shell. This begins with understanding and properly representing the lexical structure of the commands. We began by splitting token groups on the pipe. We constructed a function, called tokenize(), that would split the command into token groups based on an input we provided. Initially, we split on the pipe character, then once the token groups were separated we used our tokenize() function again to split on the spaces between commands. We did this so we could add each command to an array to keep track of it for future use. We then had to verify that each token was valid according to the given specifications. We checked to see if the tokens contained only alphanumeric characters or the acceptable special characters. If there was an invalid character in a token then we printed out an error message and moved on to the next line of input. By being able to the do this we are able to determine which lines of input are valid for the shell to process. Using a state machine in our parsing process would have been much more helpful but by the time that idea had presented itself to us we were already well on our way to finishing up the parsing portion of this assignment. Once all of the commands have been parsed, stored, and validated we move on to the steps involving redirection and piping. 
If our command list had only one argument in it, then our handle_redirects() function would fire. This function opens and closes the necessary files for the operation based on the input and location of the redirection operators. Once the proper course of action has been determined, a forked process is created. It is in the parent process that the switching of the stdin with the output text file and the stdout with the input text file occurs. It then closes the files when it is done with them but this must be done with care because if done out of order, a serious problem can be caused. If an inputfile cannot be opened then an error message stating so will be printed out. If an outputfile does not exist then this function will create one for you to store the data in. While all of this is occurring the child process is waiting for the parent process to finish up so it can move on.
Piping is along the same lines as I/O redirection but is a little trickier. First, we must use the pipe() system call before we call the fork() function. We use our function handle_pipes() to deal with the piping involved with our inputted commands. This involves closing the write file with the reading process and closing the read file with the writing process. The dup2() function is later called to take the stdout of one function and feed it into the stdin of the other appropriate function. Once these are switched the files can be closed and the execvp() function run to carry out the command.


